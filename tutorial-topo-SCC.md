# 拓扑序及强连通分解
## 排序
拓扑序和强连通分解中都需要排序，特此介绍。

程序设计中经常需要定义优先顺序进行排序，一般的做法是定义小于的关系，进而定义所有的`<,>,==,!=,>=,<=`关系。

对于两个东西`a,b`，沿用C系列语言的逻辑符号，就有：

- `!(a<b)`等价于`a>=b`
- `b<a`等价于`a>b`
- `!(a<b) && !(b<a)`等价于`a>=b && b>=a`等价于`a==b`
- `!(a==b)`等价于`a!=b`

其他关系类似推导，只要定义了小于关系，就能够确定顺序关系。所以只要给出一个判断两个东西`a,b`是否满足`a<b`的函数，就能够进行排序。

C++中能够使用标准库直接进行排序，包含头文件`#include <algorithm>`以及`using namespace std`之后。调用`sort(a, a + n)`能升序排序`a[0..n-1]`，降序排序可以`sort(a, a + n, greater<int>())`

`sort`函数的第三个参数为排序算子，定义了小于的关系，默认算子为`less<int>()`返回了`a<b`的结果，而`greater<int>()`返回了`a>b`的结果，尖括号内指定了变量`a,b`的类型。如果自己写了函数直接传入函数名即可，自己来写可以这么写：
```cpp
#include <bits/stdc++.h>

using namespace std;

bool less_(int a, int b) { return a < b; }
bool greater_(int a, int b) {return a > b; }

int main() {
    sort(a, a + n, less_);
    sort(a, a + n, greater_);
    return 0;
}
```
如果使用结构体数组对象数组之类的也是类似的，由于结构体没有默认顺序，需要传入比较算子，写一个结构体之间的比较函数即可。以下代码按照结构体先排序`x`，相同时按`y`排序，这样的结构可以使用标准库中的`pair,tuple`来替代，此处只是用作例子：
```cpp
struct P {
  int x, y;
};
bool cmp(P a, P b) {
  if (a.x == b.x) {
    return a.y < b.y;
  } else {
    return a.x < b.x;
  }
}
```

指定排序的另一种实现的方式是重载小于号，这里不进行展开。

C++11中有匿名函数，在比较算子无需多次使用的时候可以使用，方便进行理解和维护，具体方式如下：
```cpp
sort(a, a + n, [](int a, int b) {
  return a < b;
});
```

## dfs时间戳
在算法导论P350上有打时间戳的伪代码，请仔细查看，对照实现。

`v.d,v.f` 是时间戳的开始和终止时间。

`v.color` 是标记的颜色，如果将算法用栈来考虑，灰色代表了在栈中，黑色代表已经出栈，白色表示没有入栈过。容易发现此处灰色改成黑色也没什么问题，并没有地方需要判断灰色和黑色，所以只用`bool`数组就可以进行标记了。书中后续诸多性质介绍中需要区分灰色和黑色，方便理解，在实现过程中可以酌情简化。

`v.pi` 是前驱，许多时候并不需要这个属性，除非需要重构路径或者需要使用到dfs搜索树，否则可以不记录这个属性。

算法整体思路是进入一个节点记录一下时间，离开一个节点记录一下时间，进出节点时间戳增加。记得要初始化。

dfs时间戳是解决许多问题的重要手段，注意要仔细理解一下P352-353中的一些性质，否则很难理解后续的算法。

## 拓扑序
书中拓扑序的内容在P355-356，内容较少。

伪代码很短，思路是在获得了dfs的时间戳之后直接按照结束时间戳的降序进行排序。

排序的基础知识已经在前面介绍，排序的时候，一种方式是把编号和结束时间戳丢到结构体之类的里面排序，也可以对下标进行排序，即初始化一个`a[i] = i`的数组然后根据`v[x].f > v[y].f`进行排序。

## 强连通分量分解
书中伪代码在P357

第一步略过，第二步中需要计算反图，如果之前图建了全局变量，可以塞进一个结构体，声明两个图。

第三步的意思是按照结束时间戳的降序在反图上做dfs，排序部分在拓扑序中有介绍。

第四步和第三步可以一起做，意思就是每个搜索树的点构成一个强连通分量，第三步dfs的时候所有访问到的点是属于一个新的强连通分量的。

可以有一个变量记录有多少个强连通分量不断累加，一个数组记录每个点属于第几个分量。
## 强连通分量缩点
根据强连通的定义，一个点能到达强连通分量内的任意一个点一定可以到达分量内任意其他点。在考虑可达性的时候，强连通分量内的所有点可以当做是等价的。

将每个强连通分量看做一个包含一系列点的超点，分量之间有边就在超点之间连边，上述做法被称为强连通分量缩点。

强连通分量缩点之后，如果有环就会构成强连通分量与超点定义矛盾，所以超点构成了一张有向无环图，如果 u 所在的超点能够到达 v 所在的超点，那 u 也能够到达 v。

强连通分量缩点后，既保留了可达性的信息，又获得了一张更容易处理和计算的有向无环图，方便了进一步计算。

缩点构建超图时，遍历一遍所有的边，将边两端的超点连接起来即可，注意两个分量之间可以有多条边相连，需要进行去重或者保证重边不影响。

## 其他算法
拓扑序的另一种实现方式是不断将度数为0的点加入拓扑序，然后删除节点，能够dfs或者bfs实现。

强连通分量还有Tarjan算法，这种算法能够比较方便地计算割点，割边和双连通分量。

书上算法还是挺好写的，有兴趣可以了解一下其他算法。